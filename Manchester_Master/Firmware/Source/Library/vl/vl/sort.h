#pragma once
/*! \file
	\brief Алгоритмы сортировки массивов
*/
#include <cstdint>
#include "util.h"


namespace vl
{


 /*!
  \brief Классическая пирамиальная сортировка
 
  Реализация пирамедальной сортировки по возростанию сложность алгортима n*log(n), где n 
 
  \tparam T Тип, должен поддерживать операции сравнения "<" и ">"
  \param[in] n Размер массива
  \param[in,out] a[n] Массив для сортировки
 */
template<class T> void HeapSort(const uint16_t n, T a[]) {
	// ----------- Сортировка ------------
		// Сортирует по возрастанию. Чтобы получить сортировку по убыванию,
		// поменяйте знаки сравнения в строчках, помеченных /*(знак)*/
	uint16_t sh = 0; // Смещение
	bool b;
	do
	{
		b = false;
		for (int i = 0; i < n; i++)
		{
			if (i * 2 + 2 + sh < n)
			{
				if ((a[i + sh] > /*<*/ a[i * 2 + 1 + sh]) || (a[i + sh] > /*<*/ a[i * 2 + 2 + sh]))
				{
					if (a[i * 2 + 1 + sh] < /*>*/ a[i * 2 + 2 + sh])
					{
						swap(a[i + sh], a[i * 2 + 1 + sh]);
						b = true;
					}
					else if (a[i * 2 + 2 + sh] < /*>*/ a[i * 2 + 1 + sh])
					{
						swap(a[i + sh], a[i * 2 + 2 + sh]);
						b = true;
					}
				}
				// Дополнительная проверка для последних двух элементов;
				// с её помощью можно отсортировать пирамиду
				// состоящую всего лишь из трёх элементов
				if (a[i * 2 + 2 + sh] < /*>*/ a[i * 2 + 1 + sh])
				{
					swap(a[i * 2 + 1 + sh], a[i * 2 + 2 + sh]);
					b = true;
				}
			}
			else if (i * 2 + 1 + sh < n)
			{
				if (a[i + sh] > /*<*/ a[i * 2 + 1 + sh])
				{
					swap(a[i + sh], a[i * 2 + 1 + sh]);
					b = true;
				}
			}
		}
		if (!b)
			++sh; // Смещение увеличивается, когда на текущем этапе сортировать больше нечего
	} while (sh + 2 < n); // Конец сортировки

}

}